/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   controllers.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/18 16:21:10 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/22 11:24:54 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static void	logical_controller(t_info *info, t_cmd *cmd)
{
	size_t	i;

	i = 0;
	while (cmd->sub_cmd[i])
	{
		if (i == 0)
			general_controller(info, cmd->sub_cmd[i]);
		else
		{
			if (cmd->sub_cmd[i]->prev_delim == AND && !info->status)
				general_controller(info, cmd->sub_cmd[i]);
			else if (cmd->sub_cmd[i]->prev_delim == OR && info->status)
				general_controller(info, cmd->sub_cmd[i]);
		}
		i++;
	}
}

void	get_exit_status(t_info *info)
{
	int		status;
	t_pid	*current;

	current = info->running_processes;
	while (current)
	{
		waitpid(current->pid, &status, 0);
		if (WIFEXITED(status))
			info->status = WEXITSTATUS(status);
		current = current->next;
	}
	free_pid(info);
}

static void	pipe_controller(t_info *info, t_cmd *cmd)
{
	int		fd[2];
	size_t	i;
	int		ret;
	int		old_fd;

	i = 0;
	while (cmd->pipe[i])
	{
		if (cmd->pipe[i + 1])
		{
			if (pipe(fd))
			{
				write(2, "Pipe error\n", 11);
				free_info(info);
				exit (1);
			}
		}
		ret = fork();
		if (ret == -1)
		{
			write(2, "Fork error\n", 11);
			free_info(info);
			exit (1);
		}
		else if (!ret)
		{
			free_pid(info);
			if (i == 0)
			{
				dup2(fd[1], 1);
				close(fd[0]);
			}
			else if (!cmd->pipe[i + 1])
				dup2(old_fd, 0);
			else
			{
				dup2(old_fd, 0);
				dup2(fd[1], 1);
				close(fd[0]);
			}
			general_controller(info, cmd->pipe[i]);
			free_info(info);
			exit (info->status);
		}
		else
		{
			if (add_pid(info, ret))
				exit (1);
			if (i == 0)
			{
				close(fd[1]);
				old_fd = fd[0];
			}
			else if (!cmd->pipe[i + 1])
			   close(old_fd);
			else
			{
				old_fd = fd[0];
				close(fd[1]);
			}
		}
		i++;
	}
	get_exit_status(info);
}

void	fork_controller(t_info *info, t_cmd *cmd)
{
	int	ret;

	ret = fork();
	if (ret == -1)
	{
		write(2, "Fork error\n", 11);
		exit (1);
	}
	if (!ret)
	{
		free_pid(info);
		general_controller(info, cmd->fork);
		exit(info->status);
	}
	else
	{
		if (add_pid(info, ret))
		{
			write(2, "Malloc error\n", 13);
			exit (1);
		}
		get_exit_status(info);
	}
}

void	simple_controller(t_info *info, t_cmd *cmd)
{
	int	ret;

	ret = fork();
	if (ret == -1)
	{
		write(2, "Fork error\n", 13);
		exit (1);
	}
	if (!ret)
	{
		ft_execute(info, cmd->cmd_args);
	}
	else
	{
		if (add_pid(info, ret))
		{
			write(2, "Malloc error\n", 13);
			exit (1);
		}
		get_exit_status(info);
	}
}

void	general_controller(t_info *info, t_cmd *cmd)
{
	if (cmd->sub_cmd)
		logical_controller(info, cmd);
	else if (cmd->pipe)
		pipe_controller(info, cmd);
	else if (cmd->fork)
		fork_controller(info, cmd);
	else
		simple_controller(info, cmd);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   delim.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 16:28:57 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/16 16:39:27 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	is_delim(char *str, int delim)
{
	if (delim == 2 && ((*str == '|' && *(str + 1) == '|')
			|| (*str == '&' && *(str + 1) == '&')))
		return (1);
	else if (delim == 1 && *str == '|')
		return (1);
	else if (delim == 0 && (*str == '|' || *str == '&'))
		return (1);
	return (0);
}

void	save_delim(t_cmd *new_cmd, char c)
{
	if (!c)
		new_cmd->next_delim = 0;
	else if (c == '|')
		new_cmd->next_delim = 3;
	else
		new_cmd->next_delim = 2;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/21 14:23:01 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/22 11:34:34 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static size_t	count_env_var(t_info *info)
{
	t_env	*current;
	size_t	i;

	i = 0;
	current = info->env;
	while (current)
	{
		i++;
		current = current->next;
	}
	return (i);
}

static char	*join_env_var(t_env *env)
{
	char	*line;
	size_t	size;
	size_t	i;

	size = ft_strlen(env->name) + ft_strlen(env->value);
	line = (char *)malloc(sizeof(char) * (size + 2));
	size = 0;
	while (env->name[size])
	{
		line[size] = env->name[size];
		size++;
	}
	line[size] = '=';
	size++;
	i = 0;
	while (env->value[i])
		line[size++] = env->value[i++];
	line[size] = '\0';
	return (line);
}

char	**join_env(t_info *info)
{
	size_t	i;
	size_t	size;
	t_env	*current;
	char	**env_tab;

	size = count_env_var(info);
	if (!size)
	{
		env_tab = (char **)malloc(sizeof(char *));
		if (!env_tab)
			return (write (2, "Malloc error\n", 13), NULL);
		env_tab[0] = NULL;
		return (env_tab);
	}
	env_tab = (char **)malloc(sizeof(char *) * (size + 1));
	if (!env_tab)
		return (write (2, "Malloc error\n", 13), NULL);
	i = 0;
	current = info->env;
	while (i < size)
	{
		env_tab[i] = join_env_var(current);
		if (!env_tab[i])
			return (NULL);
		current = current->next;
		i++;
	}
	env_tab[i] = NULL;
	return (env_tab);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 14:19:29 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/22 12:44:26 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_env(t_info *info)
{
	t_env	*current;
	t_env	*next;

	current = info->env;
	while (current)
	{
		next = current->next;
		free(current->name);
		free(current->value);
		free(current);
		current = next;
	}
	info->env = NULL;
}

void	free_var(t_info *info)
{
	t_var	*current;
	t_var	*next;

	current = info->local_var;
	while (current)
	{
		next = current->next;
		free(current->name);
		free(current->value);
		free(current);
		current = next;
	}
	info->local_var = NULL;
}

void	free_running_processes(t_info *info)
{
	t_pid	*current;
	t_pid	*next;

	current = info->running_processes;
	while (current)
	{
		next = current->next;
		free(current);
		current = next;
	}
	info->running_processes = NULL;
}

void	free_redirect(t_cmd *cmd)
{
	t_redirect	*current;
	t_redirect	*next;

	current = cmd->in;
	while (current)
	{
		next = current->next;
		free(current->str);
		free(current);
		current = next;
	}
	current = cmd->out;
	while (current)
	{
		next = current->next;
		free(current->str);
		free(current);
		current = next;
	}
}


void	free_cmd(t_cmd *cmd)
{
	size_t	i;
	
	if (!cmd)
		return ;
	free(cmd->cmd);
	i = 0;
	if (cmd->sub_cmd)
	{
		while (cmd->sub_cmd[i])
		{
			free_cmd(cmd->sub_cmd[i]);
			free(cmd->sub_cmd[i]);
			i++;
		}
		free(cmd->sub_cmd);
	}
	else if (cmd->pipe)
	{
		while (cmd->pipe[i])
		{
			free_cmd(cmd->pipe[i]);
			free(cmd->pipe[i]);
			i++;
		}
		free(cmd->pipe);
	}
	else if (cmd->fork)
	{
		free_cmd(cmd->fork);
		free(cmd->fork);
	}
	else if (cmd->cmd_args)
	{
		while (cmd->cmd_args[i])
		{
			free(cmd->cmd_args[i]);
			i++;
		}
		free(cmd->cmd_args);
	}
	if (cmd->cmd_name)
		free(cmd->cmd_name);
	free_redirect(cmd);
}

void	free_info(t_info *info)
{
	free_env(info);
	free_var(info);
	free_running_processes(info);
	free_cmd(&info->cmd);
	rl_clear_history();
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <marvin@42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/11/22 20:08:12 by bdetune           #+#    #+#             */
/*   Updated: 2021/11/29 18:08:55 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "libft.h"

static size_t	lcl_ft_ulllen(unsigned long long n)
{
	size_t	nb_len;

	nb_len = 0;
	while (n >= 10)
	{
		nb_len++;
		n /= 10;
	}
	return (nb_len + 1);
}

static int	lcl_getsign(const char *str, size_t *i)
{
	int	sign_factor;

	sign_factor = 1;
	while (str[*i] && ft_strchr("\t\n\r\v\f ", str[*i]))
		*i += 1;
	if (str[*i] && str[*i] == '-')
	{
		sign_factor = -1;
		*i += 1;
	}
	else if (str[*i] && str[*i] == '+')
		*i += 1;
	return (sign_factor);
}

int	ft_atoi(const char *str)
{
	size_t				i;
	size_t				max_len;
	char				*nb_char;
	int					sign_factor;
	unsigned long long	ret;

	max_len = lcl_ft_ulllen(ULLONG_MAX);
	ret = 0;
	i = 0;
	sign_factor = lcl_getsign(str, &i);
	nb_char = (char *)&str[i];
	i = 0;
	while (nb_char[i] && ft_isdigit(nb_char[i]))
	{
		if ((i + 1) == max_len)
		{
			if (sign_factor < 0)
				return (0);
			else
				return ((int)ULLONG_MAX);
		}
		ret = ret * 10 + nb_char[i] - '0';
		i++;
	}
	return ((int)(sign_factor * ret));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: piboidin <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/21 11:17:22 by piboidin          #+#    #+#             */
/*   Updated: 2022/03/22 11:34:59 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	ft_is_charset(char s, char c)
{
	if (c == s)
		return (1);
	return (0);
}

int	ft_count_word(char const *s, char c)
{
	int	count;

	count = 0;
	while (*s)
	{
		while (*s && ft_is_charset(*s, c))
			s++;
		if (*s && !(ft_is_charset(*s, c)))
		{
			count++;
			while (*s && !(ft_is_charset(*s, c)))
				s++;
		}
	}
	return (count);
}

char	*ft_malloc_word(char const *s, char c)
{
	char	*word;
	int		i;

	i = 0;
	while (s[i] && !(ft_is_charset(s[i], c)))
		i++;
	word = (char *)malloc(sizeof(char) * (i + 1));
	if (!(word))
		return (NULL);
	i = 0;
	while (s[i] && !(ft_is_charset(s[i], c)))
	{
		word[i] = s[i];
		i++;
	}
	word[i] = '\0';
	return (word);
}

char	**ft_split(char const *s, char c)
{
	char	**tab;
	int		i;
	int		count;

	i = 0;
	tab = (char **)malloc(sizeof(char *) * (ft_count_word(s, c) + 1));
	if (!tab)
		return (NULL);
	count = ft_count_word(s, c);
	while (*s && (i < count))
	{
		while (*s && ft_is_charset(*s, c))
			s++;
		if (*s && !(ft_is_charset(*s, c)))
		{
			tab[i] = ft_malloc_word(s, c);
			s++;
			while (*s && !(ft_is_charset(*s, c)))
				s++;
		}
		i++;
	}
	tab[i] = NULL;
	return (tab);
}
#include "minishell.h"

size_t	ft_strlen(const char *str)
{
	size_t	i;

	if (!str)
		return (0);
	i = 0;
	while (str[i])
		i++;
	return (i);
}

void	ft_putchar(char c)
{
	write(1, &c, 1);
}

void	ft_putendl_fd(char *str, int fd)
{
	char	nline;

	nline = '\n';
	write(fd, str, ft_strlen(str));
	write(fd, &nline, 1);
}

void	ft_putstr(char *str)
{
	int	i;

	i = 0;
	while (str[i])
	{
		write(1, &str[i], 1);
		i++;
	}
}

char	*ft_trim(char *cmd)
{
	int		i;
	int		j;
	int		z;
	char	*new_cmd;

	i = 0;
	skip_whitespaces(cmd, &i);
	if (!cmd || !cmd[i])
		return (NULL);
	j = i;
	while (cmd[j + 1])
		j++;
	while (j >= i
		&& ((cmd[i + j] >= '\t' && cmd[i + j] <= '\r') || cmd[i + j] == ' ' ))
		j--;
	new_cmd = (char *)malloc(sizeof(char) * (j - i + 2));
	if (!new_cmd)
		return (NULL);
	z = 0;
	while (i <= j)
		new_cmd[z++] = cmd[i++];
	new_cmd[z] = '\0';
	return (new_cmd);
}

void	skip_whitespaces(char *cmd, int *i)
{
	if (!cmd)
		return ;
	while (cmd[*i] && ((cmd[*i] >= '\t' && cmd[*i] <= '\r') || cmd[*i] == ' '))
		*i += 1;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   init.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 14:17:01 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/22 13:04:39 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static char	*get_str(char *line, char sep, size_t *index)
{
	size_t	i;
	size_t	j;
	char	*str;

	str = NULL;
	i = *index;
	j = 0;
	while (line[i + j] && line[i + j] != sep)
		j++;
	str = (char *)malloc(sizeof(char) * (j + 1));
	if (!str)
		return (NULL);
	j = 0;
	while (line[i + j] && line[i + j] != sep)
	{
		str[j] = line[i + j];
		j++;
	}
	str[j] = '\0';
	*index += j + 1;
	return (str);
}

static int	add_to_env(t_info *info, char *line)
{
	size_t	index;
	t_env	*new_var;

	index = 0;
	new_var = NULL;
	new_var = (t_env *)malloc(sizeof(t_env));
	if (!new_var)
		return (1);
	new_var->name = NULL;
	new_var->value = NULL;
	new_var->next = NULL;
	new_var->name = get_str(line, '=', &index);
	if (!new_var->name)
		return (free(new_var), 1);
	new_var->value = get_str(line, '\0', &index);
	if (!new_var->value)
		return (free(new_var->name), free(new_var), 1);
	new_var->next = info->env;
	info->env = new_var;
	return (0);
}

void	init_cmd(t_cmd *cmd)
{
	cmd->prev_delim = 0;
	cmd->fork = NULL;
	cmd->in = NULL;
	cmd->out = NULL;
	cmd->cmd = NULL;
	cmd->cmd_name = NULL;
	cmd->cmd_args = NULL;
	cmd->pipe = NULL;
	cmd->sub_cmd = NULL;
	cmd->next_delim = 0;
}

int	create_info(t_info *info, char **envp, char *name)
{
	size_t	i;

	info->prog_name = name;
	info->local_var = NULL;
	info->running_processes = NULL;
	info->status = 0;
	info->env = NULL;
	if (envp)
	{
		i = 0;
		while (envp[i])
			i++;
		while (i--)
		{
			if (add_to_env(info, envp[i]))
				return (free_env(info), 1);
		}
	}
	init_cmd(&info->cmd);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_cmd_args.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/17 13:07:35 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/18 17:40:20 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	count_args(char *str)
{
	t_tokens	toks;
	int			i;
	int			nb_command;

	i = 0;
	nb_command = 0;
	init_tokens(&toks);
	while (str[i])
	{
		skip_whitespaces(str, &i);
		if (str[i])
			nb_command++;
		while (str[i])
		{
			save_token(str[i], &toks);
			if (!has_tokens(toks) && ((str[i] >= '\t' && str[i] <= '\r')
					|| str[i] == ' '))
				break ;
			i++;
		}
	}
	return (nb_command);
}

static char	*save_arg(char *str, int *index)
{
	char		*arg;
	t_tokens	toks;
	int			i;

	init_tokens(&toks);
	skip_whitespaces(str, index);
	i = *index;
	while (str[i])
	{
		save_token(str[i], &toks);
		if (!has_tokens(toks) && ((str[i] >= '\t' && str[i] <= '\r')
				|| str[i] == ' '))
			break ;
		i++;
	}
	str[i] = '\0';
	arg = ft_trim(&str[*index]);
	if (!arg)
		return (NULL);
	*index = i + 1;
	return (arg);
}

static char	**split_args(char *str, int nb_args)
{
	int			index;
	int			i;
	char		**tab;

	tab = (char **)malloc(sizeof(char *) * (nb_args + 1));
	if (!tab)
		return (NULL);
	i = 0;
	index = 0;
	while (i < nb_args)
	{
		tab[i] = save_arg(str, &index);
		if (!tab[i])
			return (NULL);
		i++;
	}
	tab[i] = NULL;
	return (tab);
}

int	parse_args(t_cmd *cmd)
{
	int	nb_args;

	if (!cmd->cmd)
	{
		cmd->cmd_args = (char **)malloc(sizeof(char *));
		if (!cmd->cmd_args)
			return (1);
		cmd->cmd_args[0] = NULL;
		return (0);
	}
	nb_args = count_args(cmd->cmd);
	cmd->cmd_args = split_args(cmd->cmd, nb_args);
	if (!cmd->cmd_args)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_cmd.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 20:18:37 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/21 12:28:31 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	reinit_cmd(t_cmd *cmd)
{
//	char	*trimmed_cmd;

//	trimmed_cmd = ft_trim(cmd->cmd);
//	if (!trimmed_cmd)
//		return (write(2, "Parsing error\n", 14), 1);
//	free(cmd->cmd);
//	cmd->cmd = trimmed_cmd;
	cmd->fork = NULL;
	cmd->pipe = NULL;
	cmd->sub_cmd = NULL;
	cmd->in = NULL;
	cmd->out = NULL;
	cmd->cmd_name = NULL;
	cmd->cmd_args = NULL;
	return (0);
}

int	parse_cmd(t_cmd *cmd)
{
	int		ret;

	if (reinit_cmd(cmd))
		return (1);
	ret = parse_logical(cmd);
	if (ret == 1)
		return (1);
	else if (ret)
		return (0);
	ret = parse_pipe(cmd);
	if (ret == 1)
		return (1);
	else if (ret)
		return (0);
	ret = fork_cmd(cmd);
	if (ret == 2)
		return (1);
	else if (ret)
		return (0);
	ret = parse_simple_cmd(cmd);
	if (ret)
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_fork.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 16:40:49 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/17 14:44:18 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	has_parenthesis(char *str)
{
	size_t	i;
	int		dbl_qu;
	int		spl_qu;

	dbl_qu = 0;
	spl_qu = 0;
	i = 0;
	while (str[i])
	{
		if (str[i] == dbl_qu && !spl_qu)
			dbl_qu ^= 1;
		else if (str[i] == spl_qu && !dbl_qu)
			spl_qu ^= 1;
		if (str[i] == '(' && !spl_qu && !dbl_qu)
			return (1);
		i++;
	}
	return (0);
}

int	add_redirect(char *str, t_cmd *cmd, int redirect)
{
	t_redirect	*new_redirect;

	new_redirect = (t_redirect *)malloc(sizeof(t_redirect));
	if (!new_redirect)
		return (1);
	if (redirect < 0)
	{
		new_redirect->type = -redirect;
		new_redirect->next = cmd->in;
		cmd->in = new_redirect;
	}
	else
	{
		new_redirect->type = redirect;
		new_redirect->next = cmd->out;
		cmd->out = new_redirect;
	}
	while (!(*str == '>' || *str == '<'))
		str++;
	new_redirect->str = ft_trim(&str[new_redirect->type]);
	if (!new_redirect->str)
		return (free(new_redirect), 1);
	return (0);
}

int	save_redirect(char *str, size_t i, t_cmd *cmd)
{
	int		redirect;

	if (str[i] == ')')
	{
		str[i] = '\0';
		return (0);
	}
	if (str[i] == '<' || str[i] == '>' || str[i] == '&' || str[i] == '|')
		return (1);
	while (str[i] > 32 && str[i] < 127 && str[i] != '<' && str[i] != '>'
		&& str[i] != ')' && str[i] != '(' && str[i] != '&' && str[i] != '|')
		i--;
	if (str[i] == '&' || str[i] == '|')
		return (1);
	while ((str[i] >= '\t' && str[i] <= '\r') || str[i] == ' ')
		i--;
	if (!(str[i] == '<' || str[i] == '>'))
		return (1);
	if (str[i] == '<')
	{
		redirect = -1;
		if (str[i - 1] == '<')
		{
			redirect = -2;
			i--;
		}
		i--;
	}
	else if (str[i] == '>')
	{
		redirect = 1;
		if (str[i - 1] == '>')
		{
			redirect = 2;
			i--;
		}
		i--;
	}
	while ((str[i] >= '\t' && str[i] <= '\r') || str[i] == ' ')
		i--;
	if (add_redirect(&str[i + 1], cmd, redirect))
		return (1);
	str[i + 1] = '\0';
	return (save_redirect(str, i, cmd));
}

int	fork_cmd(t_cmd *cmd)
{
	int		i;
	t_cmd	*new_cmd;

	if (!has_parenthesis(cmd->cmd))
		return (0);
	new_cmd = (t_cmd *)malloc(sizeof(t_cmd));
	if (!new_cmd)
		return (2);
	i = 0;
	skip_whitespaces(cmd->cmd, &i);
	if (cmd->cmd[i] != '(')
		return (free(new_cmd), write(2, "Parsing error\n", 14), 2);
	cmd->cmd[i] = ' ';
	while (cmd->cmd[i])
		i++;
	i--;
	if (save_redirect(cmd->cmd, i, cmd))
		return (free(new_cmd), write(2, "Parsing error\n", 14), 2);
	cmd->fork = new_cmd;
	new_cmd->cmd = ft_trim(cmd->cmd);
	if (!new_cmd->cmd)
		return (2);
	if (parse_cmd(new_cmd))
		return (2);
	return (1);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_logical.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 16:27:15 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/22 12:48:15 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_cmd	*add_cmd(char *cmd, int *i)
{
	int			is_tok;
	t_tokens	toks;
	int			j;
	t_cmd		*new_cmd;

	new_cmd = (t_cmd *)malloc(sizeof(t_cmd));
	if (!new_cmd)
		return (NULL);
	init_tokens(&toks);
	skip_whitespaces(cmd, i);
	j = 0;
	while (cmd[*i + j])
	{
		is_tok = save_token(cmd[*i + j], &toks);
		if (is_tok == 2)
			return (free(new_cmd), NULL);
		else if (!is_tok && is_delim(&cmd[*i + j], 2) && !has_tokens(toks))
			break ;
		j++;
	}
	save_delim(new_cmd, cmd[*i + j]);
	cmd[*i + j] = '\0';
	new_cmd->cmd = ft_trim(&cmd[*i]);
	if (!new_cmd->cmd)
		return (free(new_cmd), write(2, "Parsing error\n", 14), NULL);
	cmd[*i + j] = ' ';
	*i += j + 2;
	return (new_cmd);
}

static long long	count_cmds(char *cmd)
{
	int			is_tok;
	t_tokens	toks;
	size_t		i;
	long long	nb_cmds;

	init_tokens(&toks);
	nb_cmds = 0;
	i = 0;
	while (cmd[i])
	{
		is_tok = save_token(cmd[i], &toks);
		if (is_tok == 2)
			return (0);
		else if (!is_tok && is_delim(&cmd[i], 2) && !has_tokens(toks))
		{
			nb_cmds++;
			i++;
		}
			i++;
	}
	if (has_tokens(toks) || cmd[i - 1] == '|' || cmd[i - 1] == '&')
		return (0);
	nb_cmds++;
	return (nb_cmds);
}

int	parse_logical(t_cmd *cmd)
{
	int			index;
	long long	i;
	long long	j;

	if (!cmd || !cmd->cmd)
		return (1);
	if (cmd->cmd[0] == '&' || cmd->cmd[0] == '|')
		return (write(2, "Parsing error\n", 14), 1);
	i = count_cmds(cmd->cmd);
	if (!i)
		return (write(2, "Parsing error\n", 14), 1);
	else if (i == 1)
		return (0);
	cmd->sub_cmd = (t_cmd **)malloc(sizeof(t_cmd *) * (i + 1));
	if (!cmd->sub_cmd)
		return (1);
	j = 0;
	index = 0;
	while (j < i)
	{
		cmd->sub_cmd[j] = add_cmd(cmd->cmd, &index);
		if (!cmd->sub_cmd[j])
			return (1);
		if (j != 0)
			cmd->sub_cmd[j]->prev_delim = cmd->sub_cmd[j - 1]->next_delim;
		if (parse_cmd(cmd->sub_cmd[j]))
			return (1);
		j++;
	}
	cmd->sub_cmd[0]->prev_delim = 0;
	cmd->sub_cmd[i - 1]->next_delim = 0;
	cmd->sub_cmd[i] = NULL;
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_pipes.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 15:06:08 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/16 20:56:44 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static t_cmd	*add_pipe(char *cmd, int *i)
{
	int			is_tok;
	t_tokens	toks;
	int			j;
	t_cmd		*new_cmd;

	new_cmd = (t_cmd *)malloc(sizeof(t_cmd));
	if (!new_cmd)
		return (NULL);
	init_tokens(&toks);
	skip_whitespaces(cmd, i);
	j = 0;
	while (cmd[*i + j])
	{
		is_tok = save_token(cmd[*i + j], &toks);
		if (is_tok == 2)
			return (NULL);
		else if (!is_tok && cmd[*i + j] == '|' && !has_tokens(toks))
			break ;
		j++;
	}
	cmd[*i + j] = '\0';
	new_cmd->cmd = ft_trim(&cmd[*i]);
	if (!new_cmd->cmd)
		return (free(new_cmd), write(2, "Parsing error\n", 14), NULL);
	*i += j + 1;
	return (new_cmd);
}

static long long	count_pipes(char *cmd)
{
	int			is_tok;
	t_tokens	toks;
	size_t		i;
	long long	nb_cmds;

	init_tokens(&toks);
	nb_cmds = 0;
	i = 0;
	while (cmd[i])
	{
		is_tok = save_token(cmd[i], &toks);
		if (is_tok == 2)
			return (0);
		else if (!is_tok && cmd[i] == '|' && !toks.par && !toks.dbl_qu
			&& !toks.spl_qu)
			nb_cmds++;
		i++;
	}
	if (has_tokens(toks) || cmd[i - 1] == '|' || cmd[i - 1] == '&')
		return (0);
	nb_cmds++;
	return (nb_cmds);
}

int	parse_pipe(t_cmd *cmd)
{
	int			index;
	long long	i;
	long long	j;

	if (!cmd || !cmd->cmd)
		return (1);
	i = count_pipes(cmd->cmd);
	if (!i)
		return (write(2, "Parsing error\n", 14), 1);
	else if (i == 1)
		return (0);
	cmd->pipe = (t_cmd **)malloc(sizeof(t_cmd *) * (i + 1));
	if (!cmd->pipe)
		return (1);
	j = 0;
	index = 0;
	while (j < i)
	{
		cmd->pipe[j] = add_pipe(cmd->cmd, &index);
		if (!cmd->pipe[j])
			return (1);
		cmd->pipe[j]->prev_delim = 1;
		cmd->pipe[j]->next_delim = 1;
		if (parse_cmd(cmd->pipe[j]))
			return (1);
		j++;
	}
	cmd->pipe[0]->prev_delim = 0;
	cmd->pipe[i - 1]->next_delim = 0;
	cmd->pipe[i] = NULL;
	return (i);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_simple_cmd.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 20:26:23 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/18 17:40:29 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	is_valid(char *str, int i)
{
	int	spl_qu;
	int	dbl_qu;

	if (str[i] == '\0')
		return (0);
	spl_qu = 0;
	dbl_qu = 0;
	while (str[i])
	{
		if (str[i] == '"' && !spl_qu)
			dbl_qu ^= 1;
		else if (str[i] == 39 && !dbl_qu)
			spl_qu ^= 1;
		else if (!dbl_qu && !spl_qu && (str[i] == '|'
				|| str[i] == '(' || str[i] == ')'))
			return (0);
		i++;
	}
	return (1);
}

static int	add_redirect(t_cmd *cmd, int i, int redirect)
{
	t_redirect	*current;
	t_redirect	*new_redirect;

	new_redirect = (t_redirect *)malloc(sizeof(t_redirect));
	if (!new_redirect)
		return (1);
	new_redirect->next = NULL;
	if (redirect < 0)
	{
		new_redirect->type = -redirect;
		if (!cmd->in)
			cmd->in = new_redirect;
		else
		{
			current = cmd->in;
			while (current->next)
				current = current->next;
			current->next = new_redirect;
		}
	}
	else
	{
		new_redirect->type = redirect;
		if (!cmd->out)
			cmd->out = new_redirect;
		else
		{
			current = cmd->out;
			while (current->next)
				current = current->next;
			current->next = new_redirect;
		}
	}
	new_redirect->str = ft_trim(&cmd->cmd[i + new_redirect->type]);
	if (!new_redirect->str)
		return (1);
	return (0);
}

static int	save_redirect(t_cmd *cmd, char *str, int i)
{
	char		temp;
	int			end;
	int			redirect;
	int			j;
	t_tokens	toks;

	init_tokens(&toks);
	while (str[i])
	{
		save_token(str[i], &toks);
		if (!has_tokens(toks) && (str[i] == '>' || str[i] == '<'))
			break ;
		i++;
	}
	if (str[i] == '\0')
		return (0);
	j = i;
	if (str[i] == '>' && ++j)
	{
		redirect = 1;
		if (str[i + 1] == '>' && ++j)
			redirect = 2;
	}
	else if (str[i] == '<' && ++j)
	{
		redirect = -1;
		if (str[i + 1] == '<' && ++j)
			redirect = -2;
	}
	skip_whitespaces(str, &j);
	if (str[j] == '\0')
		return (1);
	while (str[j] && str[j] > 32 && str[j] < 127
		&& !(str[j] == '<' || str[j] =='>'))
		j++;
	if (str[j] != '\0')
	{
		temp = str[j];
		str[j] = '\0';
		end = 0;
	}
	else
		end = 1;
	if (add_redirect(cmd, i, redirect))
		return (1);
	while (str[i])
		str[i++] = ' ';
	if (end)
		return (0);
	else
	{
		str[i] = temp;
		return (save_redirect(cmd, cmd->cmd, i));
	}
}

int	parse_simple_cmd(t_cmd *cmd)
{
	int	i;

	i = 0;
	skip_whitespaces(cmd->cmd, &i);
	if (!is_valid(cmd->cmd, i))
		return (write (2, "Parsing error\n", 14), 1);
	if (save_redirect(cmd, cmd->cmd, i))
		return (1);
	cmd->cmd = ft_trim(cmd->cmd);
	if (parse_args(cmd))
		return (1);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pid.c                                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/21 14:05:02 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/21 14:14:15 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_pid(t_info *info)
{
	t_pid	*current;
	t_pid	*next;

	current = info->running_processes;
	while (current)
	{
		next = current->next;
		free(current);
		current = next;
	}
	info->running_processes = NULL;
}

int	add_pid(t_info *info, int pid)
{
	t_pid	*new_pid;
	t_pid	*current;

	new_pid = (t_pid *)malloc(sizeof(t_pid));
	if (!new_pid)
		return (write(2, "Malloc error\n", 13), free_info(info), 1);
	new_pid->pid = pid;
	new_pid->next = NULL;
	current = info->running_processes;
	if (current)
	{
		while (current->next)
			current = current->next;
		current->next = new_pid;
	}
	else
		info->running_processes = new_pid;
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipex_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: piboidin <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/21 11:22:58 by piboidin          #+#    #+#             */
/*   Updated: 2022/03/22 11:27:52 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

char	*ft_path(t_info *info, char *cmd)
{
	t_env	*current;
	char	**paths;
	char	*path;
	char	*path_dir;
	int		i;

	if (!info->env)
		return (NULL);
	current = info->env;
	while (current)
	{
		if (!ft_strncmp(current->name, "PATH", 5))
			break ;
		current = current->next;
	}
	if (!current)
		return (NULL);
	paths = ft_split(current->value, ':');
	i = 0;
	while (paths[i])
	{
		path_dir = ft_strjoin(paths[i], "/");
		path = ft_strjoin(path_dir, cmd);
		free(path_dir);
		if (access(path, F_OK) == 0)
			return (path);
		i++;
	}
	return (NULL);
}

void	ft_error(t_info *info)
{
	free_info(info);
	perror("Error");
	exit(EXIT_FAILURE);
}

void	ft_execute(t_info *info, char **cmd_args)
{
	char	**envp;
	char	*cmd;

	cmd = NULL;
	envp = NULL;
	cmd = ft_path(info, cmd_args[0]);
	if (!cmd)
		ft_error(info);
	envp = join_env(info);
	if (!envp)
		ft_error(info);
	if (execve(cmd, cmd_args, envp) == -1)
		ft_error(info);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokens.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: bdetune <bdetune@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/16 14:57:09 by bdetune           #+#    #+#             */
/*   Updated: 2022/03/16 18:33:55 by bdetune          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	init_tokens(t_tokens *tokens)
{
	tokens->par = 0;
	tokens->spl_qu = 0;
	tokens->dbl_qu = 0;
}

int	save_token(char c, t_tokens *toks)
{
	if (c == '"' && !toks->spl_qu)
		toks->dbl_qu ^= 1;
	else if (c == 39 && !toks->dbl_qu)
		toks->spl_qu ^= 1;
	else if (c == '(' && !toks->spl_qu && !toks->dbl_qu)
		toks->par += 1;
	else if (c == ')' && !toks->spl_qu && !toks->dbl_qu)
	{
		if (!toks->par)
			return (2);
		toks->par -= 1;
	}
	else
		return (0);
	return (1);
}

int	has_tokens(t_tokens toks)
{
	if (toks.par || toks.dbl_qu || toks.spl_qu)
		return (1);
	return (0);
}
